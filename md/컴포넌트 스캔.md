# 컴포넌트 스캔과 의존관계 자동 주입

- AppConfig에서 했던 것처럼, `@Bean`과 new~ 로 등록해야 하는 스프링 빈이 수십, 수백개가 되기도 하여 일일이 등록하기도 귀찮다.
- 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 `컴포넌트 스캔`이라는 기능을 제공한다.
- 또한 의존 관계도 자동으로 주입하는 `@Autowired`라는 기능도 제공한다.

```java
@Configuration
@ComponentScan(
        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class) // 수동 등록은 빼준다.
)
public class AutoAppConfig {
}
```
- `@Configuration`은 내부에 `@Component`가 있기에 자동으로 컴포넌트 스캔의 대상이 된다.
- 따라서 위와 같이 수동으로 등록했던(`@Configuration` 어노테이션과 `@Bean`으로 스프링 빈을 등록했던) 기존의 `AppConfig`를 스캔 대상에서 제외한다.
- 컴포넌트 스캔을 사용하기 위해 `@ComponentScan`
- 기존 AppConfig와 다르게 `@Bean`이 없어도 자동으로 빈으로 등록이 된다.


## `@ComponentScan`
- `@ComponentScan`은 `@Component`가 붙은 모든 클래스를 스프링 빈으로 등록함.
- 이 때, 스프링 빈의 기본 이름은 클래스 명을 사용하되, 맨 앞글자만 소문자로 사용!
    - **빈 이름 기본 전략** : MemberServiceImpl class -> memberServiceImpl
    - **빈 이름 직접 지정** : `@Component("dolphaGoMemberService")`
    
## `@Autowired`
- 생성자에 `@Autowired`를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
- 이때 기본 조회 전략은 `타입이 같은 빈`을 찾아서 주입한다.
    - `ac.getBean(MemberRepository.class)`와 동일하다고 이해하면 된다.
    - 그러나 충돌이 날 수도 있다. 이때는 `@Qualifier`, `@Primary` 등으로 해결한다. 뒤에서 다시 설명한다.
    